{% extends 'base.html' %}

{% block title %}Terapia Biologica - Sanità{% endblock %}

{% block content %}

<div class="terapia-content">

    <div class="row align-items-start">
        <div class="col-md-2">
            <label class="form-label mb-1">Inizio PT</label>
            <input id="therapyStart" type="date" class="form-control">
        </div>
        <div class="col-md-4">
            <!-- left intentionally empty: controllo consegne moved to Azioni -->
        </div>
        <div class="col-md-6 d-flex align-items-start justify-content-end">
            <div class="text-end">
                <label class="form-label mb-1">Azioni</label>
                <div class="d-flex gap-2">
            <button id="cancelFormBtn" class="btn btn-outline-secondary" style="display: none;" title="Cancella form (reset dati)"><i class="fas fa-eraser"></i></button>
            <button id="savePlanBtn" class="btn btn-success" style="display: none;" title="Salva piano"><i class="fas fa-check"></i></button>
            <button id="resetPlanBtn" class="btn btn-outline-danger" style="display: none;" title="Elimina piano dal DB"><i class="fas fa-trash-alt"></i></button>
                </div>
            </div>
        </div>
    </div>

    <!-- deliveries list removed: inline numbered checkboxes are used instead -->
</div>

<!-- Legend inline will be rendered in the calendar header row (left side) -->

<div class="row" id="calendarArea" data-year0="{{ current_year }}" data-year1="{{ next_year }}">
    <div class="col-12 mt-3 mb-3 d-flex align-items-center justify-content-between">
        <div class="d-flex align-items-center terapia-legend-inline">
            <div class="me-3 fw-bold">Legenda:</div>
            <div class="me-2"><span class="badge bg-success">Coperto</span></div>
            <div class="me-2"><span class="badge bg-danger">Scoperto</span></div>
            <div class="me-2"><span class="badge bg-somministrazione">Somministrazione</span></div>
            <div class="me-2"><span class="badge bg-scheduled-delivery">Consegna Programmata</span></div>
            <div><span class="badge bg-delivered">Consegna Avvenuta</span></div>
        </div>
        <div class="d-flex align-items-center gap-2">
            <button id="prevYearBtn" class="btn btn-outline-secondary" aria-label="Anno precedente"
                title="Anno precedente">
                <i class="fas fa-arrow-left"></i>
            </button>
            <h4 id="displayYearLabel" class="m-0"></h4>
            <button id="nextYearBtn" class="btn btn-outline-secondary" aria-label="Anno successivo"
                title="Anno successivo">
                <i class="fas fa-arrow-right"></i>
            </button>
        </div>
    </div>

    <div class="col-12">
        <div id="yearContainer0" class="calendar-single d-none">
            <div id="calendarYear1" class="calendar-year"></div>
        </div>
        <div id="yearContainer1" class="calendar-single d-none">
            <div id="calendarYear2" class="calendar-year"></div>
        </div>
    </div>
</div>

<!-- CSS spostato in app/static/css/templates.css -->

{% endblock %}
{% block scripts %}
<script>
    // Version: 2025-11-26-16:00 - Delivery scheduling update
    // Helper date utilities
    function parseDateInput(v) { if (!v) return null; let parts = v.split('-'); return new Date(parts[0], parseInt(parts[1], 10) - 1, parts[2]); }
    // Use global `formatISO` provided by utils-format.js (loaded in <head>)
    function startOfDay(d) { return new Date(d.getFullYear(), d.getMonth(), d.getDate()); }
    function addDays(d, n) { let r = new Date(d); r.setDate(r.getDate() + n); return r; }
    function datesEqual(a, b) { if (!a || !b) return false; return a.getFullYear() === b.getFullYear() && a.getMonth() === b.getMonth() && a.getDate() === b.getDate(); }

    function renderCalendarYear(container, year, markedMap) {
        container.innerHTML = '';
        const monthNames = ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'];
        for (let m = 0; m < 12; m++) {
            const monthDiv = document.createElement('div'); monthDiv.className = 'month';
            const title = document.createElement('div'); title.className = 'month-title'; title.textContent = monthNames[m] + ' ' + year;
            monthDiv.appendChild(title);
            const weekdays = document.createElement('div'); weekdays.className = 'weekdays';
            ['L', 'M', 'M', 'G', 'V', 'S', 'D'].forEach(w => { const el = document.createElement('div'); el.className = 'weekday'; el.textContent = w; weekdays.appendChild(el); });
            monthDiv.appendChild(weekdays);
            const days = document.createElement('div'); days.className = 'days';
            const first = new Date(year, m, 1);
            let jsdow = first.getDay();
            let offset = (jsdow + 6) % 7;
            for (let i = 0; i < offset; i++) { const e = document.createElement('div'); e.className = 'day empty'; days.appendChild(e); }
            const daysInMonth = new Date(year, m + 1, 0).getDate();
            for (let d = 1; d <= daysInMonth; d++) {
                const dt = new Date(year, m, d);
                const cell = document.createElement('div'); cell.className = 'day'; cell.setAttribute('data-date', formatISO(dt)); cell.textContent = d;
                const key = formatISO(dt);
                if (markedMap && markedMap.has(key)) {
                    const meta = markedMap.get(key);
                    
                    // Priority: delivery dates override therapy dates
                    if (meta.scheduled_delivery) {
                        if (meta.delivery_confirmed) {
                            cell.classList.add('actual-delivery');
                            cell.title = meta.title || 'Consegna confermata';
                        } else {
                            cell.classList.add('scheduled-delivery');
                            cell.title = meta.title || 'Consegna programmata';
                        }
                    } else {
                        cell.classList.add('marked');
                        // If this specific scheduled date was administered, mark accordingly
                        if (meta.administered) {
                            cell.classList.add('administered');
                            cell.title = meta.title || 'Somministrazione';
                        } else {
                        if (meta.covered) cell.classList.add('covered'); else cell.classList.add('uncovered');
                        cell.title = meta.title || (meta.covered ? 'Coperto' : 'Scoperto');
                        // if server/client flagged this scheduled date as the earliest pending, make it clickable
                        if (meta.allowed) {
                            cell.classList.add('clickable');
                            // ensure visual hint
                            cell.title = (cell.title ? cell.title + ' ' : '') + '(Questa è la prossima somministrazione da marcare)';
                        }
                    }
                    }
                }
                const t = new Date(); if (datesEqual(t, dt)) cell.classList.add('today');
                days.appendChild(cell);
            }
            // Ensure each month grid has 6 rows (6*7 = 42 cells) so boxes keep uniform height
            const totalCells = offset + daysInMonth;
            const cellsNeeded = 42 - totalCells;
            for (let k = 0; k < cellsNeeded; k++) {
                const e = document.createElement('div'); e.className = 'day empty'; days.appendChild(e);
            }
            monthDiv.appendChild(days);
            container.appendChild(monthDiv);
        }
    }

    function computeMarkedDates(startDate, endDate) {
        // Always compute ALL dates every 14 days from start for the entire 2-year period
        const arr = [];
        if (!startDate) return arr;
        let cur = startOfDay(startDate);
        while (cur <= endDate) { 
            arr.push(new Date(cur)); 
            cur = addDays(cur, 14); 
        }
        return arr;
    }

    function buildMarkedMap(startDate, deliveries, lastDay) {
        const map = new Map();
        if (!startDate) return map;
        
        // Get ALL scheduled dates (every 14 days for 2 years)
        const marked = computeMarkedDates(startDate, lastDay);
        
        // Initialize all dates as uncovered (scoperto)
        for (const md of marked) { 
            const key = formatISO(md); 
            map.set(key, { covered: false, administered: false, date: new Date(md) }); 
        }

        // Add delivery scheduled dates to the map
        for (const d of (deliveries || [])) {
            // Scheduled delivery date
            if (d.scheduled_delivery_date) {
                const key = d.scheduled_delivery_date;
                const existing = map.get(key) || { date: new Date(key) };
                const isConfirmed = d.delivery_confirmed;
                existing.scheduled_delivery = true;
                existing.delivery_confirmed = isConfirmed;
                existing.delivery_id = d.id;
                existing.delivery_number = d.delivery_number;
                existing.delivery_clickable = true;  // Always clickable for management
                existing.title = `Consegna #${d.delivery_number} ${isConfirmed ? 'confermata' : 'programmata'}`;
                map.set(key, existing);
            }
        }
        
        // Mark each scheduled date according to deliveries. A scheduled date is:
        // - 'covered' if the delivery that maps to it has been received (delivery.received === true)
        // - 'administered' if that specific dose (dose1/dose2) was recorded true
        const dl = (deliveries || []).slice().sort((a, b) => a.delivery_number - b.delivery_number);
        let idx = 0;
        let earliest_pending_idx = null;
        for (const d of dl) {
            const qty = parseInt(d.quantity || 0, 10) || 0;
            for (let j = 0; j < qty && idx < marked.length; j++, idx++) {
                const key = formatISO(marked[idx]);
                const obj = map.get(key) || { covered: false, administered: false, date: new Date(marked[idx]) };
                // covered if delivery is marked as received
                obj.covered = !!d.received;
                // administered depending on dose flags (dose1 -> j==0, dose2 -> j==1)
                if (j === 0) obj.administered = !!d.dose1; else obj.administered = !!d.dose2;
                obj.delivery_id = d.id || 'local';
                obj.delivery_number = d.delivery_number;

                // Track earliest pending dose among RECEIVED deliveries
                try {
                    if (d.received) {
                        const isAdmin = (j === 0) ? !!d.dose1 : !!d.dose2;
                        if (!isAdmin && earliest_pending_idx === null) {
                            earliest_pending_idx = idx;
                        }
                    }
                } catch (e) { /* ignore */ }

                // Add a helpful title/tooltip explaining state and dose order
                if (obj.administered) {
                    // indicate which dose was administered
                    obj.title = (j === 0) ? 'Somministrazione (dose 1)' : 'Somministrazione (dose 2)';
                } else {
                    if (obj.covered) {
                        // delivery arrived but this specific dose not yet recorded
                        if (qty >= 2) {
                            // check if dose1 has been administered already
                            const dose1Done = !!d.dose1;
                            if (!dose1Done && j === 1) {
                                obj.title = 'Coperto — devi prima marcare la dose 1; poi la dose 2.';
                            } else if (dose1Done && j === 1) {
                                obj.title = 'Coperto — dose 1 registrata, puoi marcare la dose 2.';
                            } else {
                                obj.title = 'Coperto — marcare prima dose 1, poi dose 2.';
                            }
                        } else {
                            obj.title = 'Coperto — puoi marcare la somministrazione.';
                        }
                    } else {
                        obj.title = 'Scoperto — consegna non ricevuta.';
                    }
                }
                map.set(key, obj);
            }
        }

        // If we found an earliest pending index, mark that scheduled date as allowed
        try {
            if (earliest_pending_idx !== null && earliest_pending_idx >= 0 && earliest_pending_idx < marked.length) {
                const k = formatISO(marked[earliest_pending_idx]);
                const o = map.get(k) || { covered: false, administered: false, date: new Date(marked[earliest_pending_idx]) };
                o.allowed = true;
                // augment title to invite click
                o.title = (o.title ? o.title + ' — ' : '') + 'Clicca per marcare questa somministrazione.';
                map.set(k, o);
            }
        } catch (e) { /* ignore */ }
        return map;
    }

    function annotateCoverageAndBadges(start, deliveries, years) {
        if (!start) return new Map(); 
        const lastDay = new Date(years[1], 11, 31); 
        const schedules = computeMarkedDates(start, lastDay);
        // We'll build a simple map: for each scheduled date, report whether it's covered
        // (delivery received) and which delivery covers it. Also compute remaining doses
        const map = new Map();
        const dl = (deliveries || []).slice().sort((a, b) => a.delivery_number - b.delivery_number);
        let scheduleIndex = 0;
        for (const dv of dl) {
            const qty = parseInt(dv.quantity || 0, 10) || 0;
            // compute how many doses already administered for this delivery
            const administeredCount = (dv.dose1 ? 1 : 0) + (dv.dose2 ? 1 : 0);
            const remaining = Math.max(0, qty - administeredCount);
            for (let k = 0; k < qty && scheduleIndex < schedules.length; k++, scheduleIndex++) {
                const key = formatISO(schedules[scheduleIndex]);
                map.set(key, { covered: !!dv.received, delivery_id: dv.id || 'local', delivery_number: dv.delivery_number });
            }
            // update any inline badges for delivery remaining
            const badge = document.querySelector('[data-delivery-id="' + (dv.id || 'local') + '"]');
            if (badge) badge.textContent = 'Rimanenti: ' + remaining;
        }
        return map;
    }

    document.addEventListener('DOMContentLoaded', function () {
    const therapyStartEl = document.getElementById('therapyStart');
    // 'Farmaci PT' input removed from UI — use a default value unless a plan is loaded
    const defaultTotalDrugs = 8;
    let currentTotalDrugs = defaultTotalDrugs;
    const savePlanBtn = document.getElementById('savePlanBtn');
        const yearEls = [document.getElementById('calendarYear1'), document.getElementById('calendarYear2')];
        
        // Hide all buttons initially - they will be shown by updateButtonStates() after loadPlan()
        const allButtons = [savePlanBtn, document.getElementById('cancelFormBtn'), document.getElementById('resetPlanBtn')];
        allButtons.forEach(btn => { if (btn) { btn.style.cssText = 'display: none !important;'; btn.disabled = true; } });
        const containerEls = [document.getElementById('yearContainer0'), document.getElementById('yearContainer1')];
        const displayYearLabel = document.getElementById('displayYearLabel');
        const prevBtn = document.getElementById('prevYearBtn');
        const nextBtn = document.getElementById('nextYearBtn');
        const terapiaContentEl = document.querySelector('.terapia-content');
        // Legend is inline in the header; no dynamic positioning required.
        const area = document.getElementById('calendarArea');
        const years = [parseInt(area.dataset.year0, 10), parseInt(area.dataset.year1, 10)];
        let activeIndex = 0;

    const today = new Date(); therapyStartEl.value = formatISO(today); currentTotalDrugs = defaultTotalDrugs;

        let currentPlan = null;
    let localPlannedDeliveries = computePlannedDeliveries(currentTotalDrugs, parseDateInput(therapyStartEl.value));
        // Note: do NOT mark any delivery as received for unsaved (local) plans.
        let displayedDeliveries = [];

        // compute planned deliveries
        function computePlannedDeliveries(total, startDate) {
            const list = []; 
            const n = Math.floor((parseInt(total, 10) || 0) / 2);
            for (let i = 0; i < n; i++) { 
                list.push({ 
                    id: null, 
                    delivery_number: i + 1, 
                    quantity: 2, 
                    received: false 
                }); 
            }
            return list;
        }

        // renderDeliveries: store deliveries for the UI and update counts
        function renderDeliveries(deliveries) {
            if (!deliveries || deliveries.length === 0) { displayedDeliveries = []; return; }
            displayedDeliveries = deliveries;
        }

        function refresh() {
            const start = parseDateInput(therapyStartEl.value); 
            const lastDay = new Date(years[1], 11, 31);
            const deliveries = (currentPlan && currentPlan.deliveries) ? currentPlan.deliveries : localPlannedDeliveries;
            const coverageMap = annotateCoverageAndBadges(start, deliveries, years); 
            const markedMap = buildMarkedMap(start, deliveries, lastDay);
            for (const [k, info] of coverageMap.entries()) { 
                if (markedMap.has(k)) { 
                    const m = markedMap.get(k); 
                    m.covered = info.covered; 
                    if (info.delivery_date) m.covering_delivery_date = formatISO(info.delivery_date); 
                    markedMap.set(k, m); 
                } 
            }
            renderCalendarYear(yearEls[0], years[0], markedMap); 
            renderCalendarYear(yearEls[1], years[1], markedMap); 
            showIndex(activeIndex);
        }

        function showIndex(i) { activeIndex = i; displayYearLabel.textContent = years[i]; containerEls.forEach((c, idx) => { if (idx === i) c.classList.remove('d-none'); else c.classList.add('d-none'); }); prevBtn.disabled = (i === 0); nextBtn.disabled = (i === years.length - 1); }

        function updateButtonStates() {
            const hasPlan = !!currentPlan;
            const resetPlanBtn = document.getElementById('resetPlanBtn');
            const cancelFormBtn = document.getElementById('cancelFormBtn');
            
            // Disable therapy start input when a saved plan exists
            try {
                if (therapyStartEl) therapyStartEl.disabled = hasPlan;
            } catch (e) { }
            
            if (hasPlan) {
                // plan saved: hide Save and Cancel, show Delete
                if (savePlanBtn) {
                    savePlanBtn.style.cssText = 'display: none !important;';
                    savePlanBtn.disabled = true;
                }
                if (cancelFormBtn) {
                    cancelFormBtn.style.cssText = 'display: none !important;';
                    cancelFormBtn.disabled = true;
                }
                if (resetPlanBtn) {
                    resetPlanBtn.style.cssText = '';
                    resetPlanBtn.disabled = false;
                }
            } else {
                // no plan: show Save and Cancel, hide Delete
                if (savePlanBtn) {
                    savePlanBtn.style.cssText = '';
                    savePlanBtn.disabled = false;
                }
                if (cancelFormBtn) {
                    cancelFormBtn.style.cssText = '';
                    cancelFormBtn.disabled = false;
                }
                if (resetPlanBtn) {
                    resetPlanBtn.style.cssText = 'display: none !important;';
                    resetPlanBtn.disabled = true;
                }
            }
        }

        prevBtn.addEventListener('click', function () { if (activeIndex > 0) { showIndex(activeIndex - 1); } });
        nextBtn.addEventListener('click', function () { if (activeIndex < years.length - 1) { showIndex(activeIndex + 1); } });

        savePlanBtn.addEventListener('click', function () {
            // Simple: always create a new plan (server will check if one exists)
            const payload = { 
                start_date: therapyStartEl.value, 
                total_drugs: parseInt(currentTotalDrugs, 10) || 0
            };
            postForm('/sanita/api/plan', payload)
                .then(function(js) {
                    if (js.error) { 
                        if (js.error === 'plan_exists') {
                            window.showToast('Esiste già un piano. Eliminarlo prima di crearne uno nuovo.', 'warning');
                        } else {
                            window.showToast('Errore salvataggio piano', 'danger'); 
                        }
                        return; 
                    }
                    currentPlan = js.plan;
                    displayedDeliveries = currentPlan.deliveries || [];
                    renderDeliveries(displayedDeliveries);
                    updateButtonStates();
                    refresh();
                    window.showToast('Piano salvato', 'success');
                }).catch(() => { window.showToast('Errore salvataggio', 'danger'); });
        });

        // Plan extension UI and handler removed.

        // When therapy start changes, recompute local planned deliveries using currentTotalDrugs
        therapyStartEl.addEventListener('input', function () { 
            const start = parseDateInput(therapyStartEl.value); 
            localPlannedDeliveries = computePlannedDeliveries(currentTotalDrugs, start); 
            // If no plan saved, keep localPlannedDeliveries unmarked (no covered dates)
            renderDeliveries(localPlannedDeliveries); 
            refresh(); 
        });

        const resetPlanBtn = document.getElementById('resetPlanBtn');
        resetPlanBtn.addEventListener('click', function () {
            var msg = 'Confermi la cancellazione del piano terapeutico? Questa operazione è irreversibile.';
            var confirmFn = (window.showGlobalConfirm && typeof window.showGlobalConfirm === 'function') ? window.showGlobalConfirm : function(m){ return Promise.resolve(confirm(m)); };
            confirmFn(msg).then(function(confirmed){
                if (!confirmed) return;
                postForm('/sanita/api/plan', null, { method: 'DELETE' }).then(function(js) {
                    if (js.error) { window.showToast('Errore cancellazione piano', 'danger'); return; }
                    currentPlan = null; 
                    displayedDeliveries = []; 
                    currentTotalDrugs = defaultTotalDrugs;
                    therapyStartEl.value = formatISO(new Date()); 
                    localPlannedDeliveries = computePlannedDeliveries(currentTotalDrugs, parseDateInput(therapyStartEl.value));
                    // Keep local planned deliveries unmarked when no plan exists
                    renderDeliveries(localPlannedDeliveries);
                    // No per-delivery inline UI anymore
                    updateButtonStates();
                    refresh(); 
                    window.showToast('Piano cancellato', 'success');
                }).catch(() => { window.showToast('Errore cancellazione', 'danger'); });
            }).catch(function(){});
        });

        const cancelFormBtn = document.getElementById('cancelFormBtn');
        cancelFormBtn.addEventListener('click', function () { 
            therapyStartEl.value = formatISO(new Date()); 
            currentTotalDrugs = defaultTotalDrugs;
            localPlannedDeliveries = computePlannedDeliveries(currentTotalDrugs, parseDateInput(therapyStartEl.value)); 
            // Keep local planned deliveries unmarked when no plan exists
            renderDeliveries(localPlannedDeliveries); 
            currentPlan = null;
            updateButtonStates();
            refresh(); 
        });

        function loadPlan() { 
            postForm('/sanita/api/plan', null, { method: 'GET', expect: 'json' }).then(js => { 
                if (js && js.plan) { 
                    currentPlan = js.plan; 
                    therapyStartEl.value = currentPlan.start_date || therapyStartEl.value; 
                    // update internal total drugs from plan
                    currentTotalDrugs = currentPlan.total_drugs || currentTotalDrugs;
                    displayedDeliveries = currentPlan.deliveries || [];
                    renderDeliveries(displayedDeliveries); 
                } else {
                    currentPlan = null;
                    displayedDeliveries = localPlannedDeliveries;
                    // Keep local planned deliveries unmarked when no plan exists
                    renderDeliveries(localPlannedDeliveries);
                }
                    updateButtonStates();
                    refresh(); 
            }).catch(() => { 
                window.showToast('Errore caricamento piano', 'danger'); 
            }); 
        }

        // Click handler for day cells: 
        // - For therapy dates (marked): mark as administered
        // - For delivery dates: schedule/confirm/cancel delivery
        function onCalendarDayClick(ev) {
            const target = ev.target.closest('.day');
            if (!target || target.classList.contains('empty')) return;
            const key = target.getAttribute('data-date');
            if (!key) return;
            
            if (!currentPlan) {
                window.showToast('Crea prima un piano terapeutico', 'warning');
                return;
            }
            
            // Check if this date has a delivery scheduled
            const start = parseDateInput(therapyStartEl.value);
            const lastDay = new Date(years[1], 11, 31);
            const markedMap = buildMarkedMap(start, currentPlan.deliveries || [], lastDay);
            const dateInfo = markedMap.get(key);
            
            // Handle delivery dates
            if (dateInfo && dateInfo.delivery_clickable) {
                handleDeliveryDateClick(key, dateInfo);
                return;
            }
            
            // Handle therapy administration dates (original logic)
            // Only act on scheduled dates (marked)
            if (!target.classList.contains('marked')) {
                // Check if this is a potential delivery scheduling date
                // Allow clicking on any date to schedule a delivery if there are unscheduled deliveries
                const hasUnscheduled = (currentPlan.deliveries || []).some(d => !d.scheduled_delivery_date);
                if (hasUnscheduled) {
                    handleDeliveryScheduling(key);
                }
                return;
            }
            
            // Original therapy date logic
            // Only allow clicking the earliest pending scheduled dose: client-side guard.
            if (!target.classList.contains('clickable')) {
                const req = document.querySelector('.day.clickable');
                if (req && req.getAttribute) {
                    const rd = req.getAttribute('data-date');
                    try { window.showToast('Devi prima marcare la somministrazione del ' + formatDisplayDate(new Date(rd)), 'warning'); } catch(e) { window.showToast('Devi prima marcare la somministrazione precedente.','warning'); }
                } else {
                    window.showToast('Questa data non è cliccabile in questo momento.', 'warning');
                }
                return;
            }
            // If already administered, do not allow re-marking
            if (target.classList.contains('administered')) {
                window.showToast('Questa data è già marcata come somministrazione.', 'info');
                return;
            }
            // Only allow marking when the date is covered (delivery received)
            if (!target.classList.contains('covered')) {
                window.showToast('La data selezionata non è coperta da una fornitura ricevuta; non è possibile marcare la somministrazione.', 'warning');
                return;
            }
            // Confirm with the user
            const pretty = formatPrettyDate(new Date(key));
            var confirmMsg = 'Vuoi marcare la somministrazione per il ' + pretty + ' ?';
            var confirmFn = (window.showGlobalConfirm && typeof window.showGlobalConfirm === 'function') ? window.showGlobalConfirm : function(m){ return Promise.resolve(confirm(m)); };
            confirmFn(confirmMsg).then(function(confirmed){
                if (!confirmed) return;
                // Call backend to mark the delivery that covers this date
                postForm('/sanita/api/delivery/mark_date', { date: key })
                    .then(function(js) {
                    if (js.error) {
                            const msg = js.message || js.error;
                            if (js.error === 'already_received') {
                                window.showToast(msg || 'Questa somministrazione è già stata marcata.', 'info');
                            } else if (js.error === 'date_not_scheduled') {
                                window.showToast(msg || 'La data selezionata non corrisponde a una somministrazione programmata.', 'warning');
                            } else if (js.error === 'not_covered') {
                                window.showToast(msg || 'La consegna non è ancora stata ricevuta. Aggiungi la consegna prima di marcare la somministrazione.', 'warning');
                            } else if (js.error === 'order_violation') {
                                // If server suggests a required_date, show it nicely
                                if (js.required_date) {
                                    const rd = js.required_date;
                                    const prettyReq = formatDisplayDate(new Date(rd));
                                    window.showToast((msg || 'Devi prima marcare la prima dose della consegna.') + ' Data suggerita: ' + prettyReq, 'warning');
                                } else {
                                    window.showToast(msg || 'Devi prima marcare la prima dose della consegna.', 'warning');
                                }
                            } else {
                                window.showToast(msg || 'Errore marcatura data', 'danger');
                            }
                        return;
                    }
                    // Update local state and UI
                    currentPlan = js.plan;
                    displayedDeliveries = currentPlan.deliveries || [];
                    renderDeliveries(displayedDeliveries);
                    updateButtonStates();
                    refresh();
                    window.showToast('Somministrazione registrata', 'success');
                }).catch(() => { window.showToast('Errore marcatura', 'danger'); });
            });
        }
        
        // Handle clicking on a delivery date (scheduled or confirmed)
        function handleDeliveryDateClick(dateKey, dateInfo) {
            if (dateInfo.delivery_confirmed) {
                // Already confirmed - show info only
                window.showToast('Questa consegna è già stata confermata', 'info');
                return;
            }
            
            // Scheduled but not confirmed - ask to confirm or cancel
            const pretty = formatPrettyDate(new Date(dateKey));
            const deliveryNum = dateInfo.delivery_number || '?';
            
            // Create custom confirmation dialog with two action buttons
            const modalHtml = `
                <div class="modal fade" id="deliveryActionModal" tabindex="-1" aria-hidden="true">
                    <div class="modal-dialog modal-dialog-centered">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title">Consegna #${deliveryNum}</h5>
                                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                            </div>
                            <div class="modal-body">
                                <p>Consegna programmata per <strong>${pretty}</strong></p>
                                <p>Cosa vuoi fare?</p>
                            </div>
                            <div class="modal-footer d-flex justify-content-between">
                                <button type="button" class="btn btn-outline-danger" id="deliveryCancelBtn">
                                    <i class="fas fa-times"></i> Cancella programmazione
                                </button>
                                <button type="button" class="btn btn-success" id="deliveryConfirmBtn">
                                    <i class="fas fa-check"></i> Conferma ricezione
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Remove any existing modal
            const existingModal = document.getElementById('deliveryActionModal');
            if (existingModal) existingModal.remove();
            
            // Add modal to body
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            
            const modalEl = document.getElementById('deliveryActionModal');
            const modal = new bootstrap.Modal(modalEl);
            
            // Handle confirm button
            document.getElementById('deliveryConfirmBtn').addEventListener('click', function() {
                modal.hide();
                postForm('/sanita/api/delivery/click-date', { date: dateKey, action: 'confirm' })
                    .then(handleDeliveryResponse)
                    .catch(() => { window.showToast('Errore conferma consegna', 'danger'); });
            });
            
            // Handle cancel button
            document.getElementById('deliveryCancelBtn').addEventListener('click', function() {
                modal.hide();
                postForm('/sanita/api/delivery/click-date', { date: dateKey, action: 'cancel' })
                    .then(handleDeliveryResponse)
                    .catch(() => { window.showToast('Errore cancellazione programmazione', 'danger'); });
            });
            
            // Clean up modal after hidden
            modalEl.addEventListener('hidden.bs.modal', function() {
                modalEl.remove();
            });
            
            modal.show();
        }
        
        // Handle clicking on an empty date to schedule a delivery
        function handleDeliveryScheduling(dateKey) {
            const pretty = formatPrettyDate(new Date(dateKey));
            const message = `Vuoi programmare una consegna per il ${pretty}?`;
            
            var confirmFn = (window.showGlobalConfirm && typeof window.showGlobalConfirm === 'function') ? window.showGlobalConfirm : function(m){ return Promise.resolve(confirm(m)); };
            confirmFn(message).then(function(confirmed){
                if (!confirmed) return;
                
                postForm('/sanita/api/delivery/click-date', { date: dateKey, action: 'schedule' })
                    .then(handleDeliveryResponse)
                    .catch(() => { window.showToast('Errore programmazione consegna', 'danger'); });
            }).catch(function(){});
        }
        
        // Handle API response for delivery operations
        function handleDeliveryResponse(js) {
            if (js.error) {
                const msg = js.message || js.error;
                if (js.error === 'already_scheduled') {
                    window.showToast(msg || 'Questa data ha già una consegna programmata', 'warning');
                } else if (js.error === 'no_available') {
                    window.showToast(msg || 'Non ci sono consegne disponibili da programmare', 'warning');
                } else if (js.error === 'already_confirmed') {
                    window.showToast(msg || 'Questa consegna è già stata confermata', 'info');
                } else if (js.error === 'not_found') {
                    window.showToast(msg || 'Nessuna consegna programmata per questa data', 'warning');
                } else {
                    window.showToast(msg || 'Errore operazione consegna', 'danger');
                }
                return;
            }
            
            // Update local state and UI
            currentPlan = js.plan;
            displayedDeliveries = currentPlan.deliveries || [];
            renderDeliveries(displayedDeliveries);
            updateButtonStates();
            refresh();
            
            const successMsg = js.message || 'Operazione completata';
            window.showToast(successMsg, 'success');
        }

        // Attach delegated listener to both year containers
        const calendarYearEls = [document.getElementById('calendarYear1'), document.getElementById('calendarYear2')];
        calendarYearEls.forEach(yr => { if (yr) yr.addEventListener('click', onCalendarDayClick); });

        loadPlan();
        refresh();
    }); // Close DOMContentLoaded event handler
</script>

{% endblock %}