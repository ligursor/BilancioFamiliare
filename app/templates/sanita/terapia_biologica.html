{% extends 'base.html' %}

{% block title %}Terapia Biologica - Sanità{% endblock %}

{% block content %}

<div class="terapia-content">

    <div class="row align-items-start">
        <div class="col-md-2">
            <label class="form-label mb-1">Inizio PT</label>
            <input id="therapyStart" type="date" class="form-control">
        </div>
        <div class="col-md-4">
            <!-- left intentionally empty: controllo consegne moved to Azioni -->
        </div>
        <div class="col-md-6 d-flex align-items-start justify-content-end">
            <div class="text-end">
                <label class="form-label mb-1">Azioni</label>
                <div class="d-flex gap-2">
            <button id="cancelFormBtn" class="btn btn-outline-secondary" title="Cancella form (reset dati)"><i class="fas fa-eraser"></i></button>
            <button id="savePlanBtn" class="btn btn-success" title="Salva piano"><i class="fas fa-check"></i></button>
            
            <!-- Add delivery button (marks next delivery as received) - hidden until a plan is saved -->
            <button id="addDeliveryBtn" class="btn btn-primary d-none" title="Aggiungi consegna"><i class="fas fa-plus"></i></button>
            <span id="addDeliverySpinner" class="spinner-border spinner-border-sm text-primary ms-2 d-none" role="status" aria-hidden="true"></span>
            <span id="addDeliveryText" class="ms-2 small text-muted d-none"></span>
            <button id="resetPlanBtn" class="btn btn-outline-danger" title="Elimina piano dal DB"><i class="fas fa-trash-alt"></i></button>
                </div>
            </div>
        </div>
    </div>

    <!-- deliveries list removed: inline numbered checkboxes are used instead -->
</div>

<!-- Legend inline will be rendered in the calendar header row (left side) -->

<div class="row" id="calendarArea" data-year0="{{ current_year }}" data-year1="{{ next_year }}">
    <div class="col-12 mt-3 mb-3 d-flex align-items-center justify-content-between">
        <div class="d-flex align-items-center terapia-legend-inline">
            <div class="me-3 fw-bold">Legenda:</div>
            <div class="me-2"><span class="badge bg-success">Coperto</span></div>
            <div class="me-2"><span class="badge bg-danger">Scoperto</span></div>
            <div><span class="badge bg-somministrazione">Somministrazione</span></div>
        </div>
        <div class="d-flex align-items-center gap-2">
            <button id="prevYearBtn" class="btn btn-outline-secondary" aria-label="Anno precedente"
                title="Anno precedente">
                <i class="fas fa-arrow-left"></i>
            </button>
            <h4 id="displayYearLabel" class="m-0"></h4>
            <button id="nextYearBtn" class="btn btn-outline-secondary" aria-label="Anno successivo"
                title="Anno successivo">
                <i class="fas fa-arrow-right"></i>
            </button>
        </div>
    </div>

    <div class="col-12">
        <div id="yearContainer0" class="calendar-single d-none">
            <div id="calendarYear1" class="calendar-year"></div>
        </div>
        <div id="yearContainer1" class="calendar-single d-none">
            <div id="calendarYear2" class="calendar-year"></div>
        </div>
    </div>
</div>

<!-- CSS spostato in app/static/css/templates.css -->

{% endblock %}
{% block scripts %}
<script>
    // Helper date utilities
    function parseDateInput(v) { if (!v) return null; let parts = v.split('-'); return new Date(parts[0], parseInt(parts[1], 10) - 1, parts[2]); }
    // Use global `formatISO` provided by utils-format.js (loaded in <head>)
    function startOfDay(d) { return new Date(d.getFullYear(), d.getMonth(), d.getDate()); }
    function addDays(d, n) { let r = new Date(d); r.setDate(r.getDate() + n); return r; }
    function datesEqual(a, b) { if (!a || !b) return false; return a.getFullYear() === b.getFullYear() && a.getMonth() === b.getMonth() && a.getDate() === b.getDate(); }

    function renderCalendarYear(container, year, markedMap) {
        container.innerHTML = '';
        const monthNames = ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'];
        for (let m = 0; m < 12; m++) {
            const monthDiv = document.createElement('div'); monthDiv.className = 'month';
            const title = document.createElement('div'); title.className = 'month-title'; title.textContent = monthNames[m] + ' ' + year;
            monthDiv.appendChild(title);
            const weekdays = document.createElement('div'); weekdays.className = 'weekdays';
            ['L', 'M', 'M', 'G', 'V', 'S', 'D'].forEach(w => { const el = document.createElement('div'); el.className = 'weekday'; el.textContent = w; weekdays.appendChild(el); });
            monthDiv.appendChild(weekdays);
            const days = document.createElement('div'); days.className = 'days';
            const first = new Date(year, m, 1);
            let jsdow = first.getDay();
            let offset = (jsdow + 6) % 7;
            for (let i = 0; i < offset; i++) { const e = document.createElement('div'); e.className = 'day empty'; days.appendChild(e); }
            const daysInMonth = new Date(year, m + 1, 0).getDate();
            for (let d = 1; d <= daysInMonth; d++) {
                const dt = new Date(year, m, d);
                const cell = document.createElement('div'); cell.className = 'day'; cell.setAttribute('data-date', formatISO(dt)); cell.textContent = d;
                const key = formatISO(dt);
                if (markedMap && markedMap.has(key)) {
                    const meta = markedMap.get(key);
                    cell.classList.add('marked');
                    // If this specific scheduled date was administered, mark accordingly
                    if (meta.administered) {
                        cell.classList.add('administered');
                        cell.title = meta.title || 'Somministrazione';
                    } else {
                        if (meta.covered) cell.classList.add('covered'); else cell.classList.add('uncovered');
                        cell.title = meta.title || (meta.covered ? 'Coperto' : 'Scoperto');
                        // if server/client flagged this scheduled date as the earliest pending, make it clickable
                        if (meta.allowed) {
                            cell.classList.add('clickable');
                            // ensure visual hint
                            cell.title = (cell.title ? cell.title + ' ' : '') + '(Questa è la prossima somministrazione da marcare)';
                        }
                    }
                }
                const t = new Date(); if (datesEqual(t, dt)) cell.classList.add('today');
                days.appendChild(cell);
            }
            // Ensure each month grid has 6 rows (6*7 = 42 cells) so boxes keep uniform height
            const totalCells = offset + daysInMonth;
            const cellsNeeded = 42 - totalCells;
            for (let k = 0; k < cellsNeeded; k++) {
                const e = document.createElement('div'); e.className = 'day empty'; days.appendChild(e);
            }
            monthDiv.appendChild(days);
            container.appendChild(monthDiv);
        }
    }

    function computeMarkedDates(startDate, endDate) {
        // Always compute ALL dates every 14 days from start for the entire 2-year period
        const arr = [];
        if (!startDate) return arr;
        let cur = startOfDay(startDate);
        while (cur <= endDate) { 
            arr.push(new Date(cur)); 
            cur = addDays(cur, 14); 
        }
        return arr;
    }

    function buildMarkedMap(startDate, deliveries, lastDay) {
        const map = new Map();
        if (!startDate) return map;
        
        // Get ALL scheduled dates (every 14 days for 2 years)
        const marked = computeMarkedDates(startDate, lastDay);
        
        // Initialize all dates as uncovered (scoperto)
        for (const md of marked) { 
            const key = formatISO(md); 
            map.set(key, { covered: false, administered: false, date: new Date(md) }); 
        }
        
        // Mark each scheduled date according to deliveries. A scheduled date is:
        // - 'covered' if the delivery that maps to it has been received (delivery.received === true)
        // - 'administered' if that specific dose (dose1/dose2) was recorded true
        const dl = (deliveries || []).slice().sort((a, b) => a.delivery_number - b.delivery_number);
        let idx = 0;
        let earliest_pending_idx = null;
        for (const d of dl) {
            const qty = parseInt(d.quantity || 0, 10) || 0;
            for (let j = 0; j < qty && idx < marked.length; j++, idx++) {
                const key = formatISO(marked[idx]);
                const obj = map.get(key) || { covered: false, administered: false, date: new Date(marked[idx]) };
                // covered if delivery is marked as received
                obj.covered = !!d.received;
                // administered depending on dose flags (dose1 -> j==0, dose2 -> j==1)
                if (j === 0) obj.administered = !!d.dose1; else obj.administered = !!d.dose2;
                obj.delivery_id = d.id || 'local';
                obj.delivery_number = d.delivery_number;

                // Track earliest pending dose among RECEIVED deliveries
                try {
                    if (d.received) {
                        const isAdmin = (j === 0) ? !!d.dose1 : !!d.dose2;
                        if (!isAdmin && earliest_pending_idx === null) {
                            earliest_pending_idx = idx;
                        }
                    }
                } catch (e) { /* ignore */ }

                // Add a helpful title/tooltip explaining state and dose order
                if (obj.administered) {
                    // indicate which dose was administered
                    obj.title = (j === 0) ? 'Somministrazione (dose 1)' : 'Somministrazione (dose 2)';
                } else {
                    if (obj.covered) {
                        // delivery arrived but this specific dose not yet recorded
                        if (qty >= 2) {
                            // check if dose1 has been administered already
                            const dose1Done = !!d.dose1;
                            if (!dose1Done && j === 1) {
                                obj.title = 'Coperto — devi prima marcare la dose 1; poi la dose 2.';
                            } else if (dose1Done && j === 1) {
                                obj.title = 'Coperto — dose 1 registrata, puoi marcare la dose 2.';
                            } else {
                                obj.title = 'Coperto — marcare prima dose 1, poi dose 2.';
                            }
                        } else {
                            obj.title = 'Coperto — puoi marcare la somministrazione.';
                        }
                    } else {
                        obj.title = 'Scoperto — consegna non ricevuta.';
                    }
                }
                map.set(key, obj);
            }
        }

        // If we found an earliest pending index, mark that scheduled date as allowed
        try {
            if (earliest_pending_idx !== null && earliest_pending_idx >= 0 && earliest_pending_idx < marked.length) {
                const k = formatISO(marked[earliest_pending_idx]);
                const o = map.get(k) || { covered: false, administered: false, date: new Date(marked[earliest_pending_idx]) };
                o.allowed = true;
                // augment title to invite click
                o.title = (o.title ? o.title + ' — ' : '') + 'Clicca per marcare questa somministrazione.';
                map.set(k, o);
            }
        } catch (e) { /* ignore */ }
        return map;
    }

    // Update the small preview text near the Add Delivery button showing which dates will be covered
    function updateAddDeliveryPreview() {
        try {
            if (!addDeliveryBtn || !addDeliveryText) return;
            // Only show preview when a plan exists
            if (!currentPlan) {
                addDeliveryText.classList.add('d-none');
                addDeliveryBtn.title = 'Aggiungi consegna';
                return;
            }
            const info = computeNextDeliveryDates();
            if (!info) {
                addDeliveryText.classList.add('d-none');
                addDeliveryBtn.title = 'Nessuna consegna pendente';
                return;
            }
            const dates = info.dates || [];
            const pretty = dates.length ? dates.map(d => formatDisplayDate(d)).join(', ') : '(nessuna data prevista)';
            const msg = `Consegna #${info.delivery_number} — Coprirà: ${pretty}`;
            addDeliveryBtn.title = msg;
            // Only show preview text when not actively sending
            const spinnerActive = addDeliverySpinner && !addDeliverySpinner.classList.contains('d-none');
            if (!spinnerActive) {
                addDeliveryText.textContent = msg;
                addDeliveryText.classList.remove('d-none');
            }
        } catch (e) { console && console.error && console.error('updateAddDeliveryPreview error', e); }
    }

    document.addEventListener('DOMContentLoaded', function () {
    const therapyStartEl = document.getElementById('therapyStart');
    // 'Farmaci PT' input removed from UI — use a default value unless a plan is loaded
    const defaultTotalDrugs = 8;
    let currentTotalDrugs = defaultTotalDrugs;
    const savePlanBtn = document.getElementById('savePlanBtn');
        const yearEls = [document.getElementById('calendarYear1'), document.getElementById('calendarYear2')];
        const containerEls = [document.getElementById('yearContainer0'), document.getElementById('yearContainer1')];
        const displayYearLabel = document.getElementById('displayYearLabel');
        const prevBtn = document.getElementById('prevYearBtn');
        const nextBtn = document.getElementById('nextYearBtn');
    const terapiaContentEl = document.querySelector('.terapia-content');
    const addDeliveryBtn = document.getElementById('addDeliveryBtn');
    const addDeliverySpinner = document.getElementById('addDeliverySpinner');
    const addDeliveryText = document.getElementById('addDeliveryText');
        // Legend is inline in the header; no dynamic positioning required.

        const area = document.getElementById('calendarArea');
        const years = [parseInt(area.dataset.year0, 10), parseInt(area.dataset.year1, 10)];
        let activeIndex = 0;

    const today = new Date(); therapyStartEl.value = formatISO(today); currentTotalDrugs = defaultTotalDrugs;

        let currentPlan = null;
    let localPlannedDeliveries = computePlannedDeliveries(currentTotalDrugs, parseDateInput(therapyStartEl.value));
        // Note: do NOT mark any delivery as received for unsaved (local) plans.
        let displayedDeliveries = [];

        // compute planned deliveries
        function computePlannedDeliveries(total, startDate) {
            const list = []; 
            const n = Math.floor((parseInt(total, 10) || 0) / 2);
            for (let i = 0; i < n; i++) { 
                list.push({ 
                    id: null, 
                    delivery_number: i + 1, 
                    quantity: 2, 
                    received: false 
                }); 
            }
            return list;
        }

        // renderDeliveries: store deliveries for the UI and update counts
        function renderDeliveries(deliveries) {
            if (!deliveries || deliveries.length === 0) { displayedDeliveries = []; return; }
            displayedDeliveries = deliveries;
        }

        function refresh() {
            const start = parseDateInput(therapyStartEl.value); 
            const lastDay = new Date(years[1], 11, 31);
            const deliveries = (currentPlan && currentPlan.deliveries) ? currentPlan.deliveries : localPlannedDeliveries;
            const coverageMap = annotateCoverageAndBadges(start, deliveries); 
            const markedMap = buildMarkedMap(start, deliveries, lastDay);
            for (const [k, info] of coverageMap.entries()) { 
                if (markedMap.has(k)) { 
                    const m = markedMap.get(k); 
                    m.covered = info.covered; 
                    if (info.delivery_date) m.covering_delivery_date = formatISO(info.delivery_date); 
                    markedMap.set(k, m); 
                } 
            }
            renderCalendarYear(yearEls[0], years[0], markedMap); 
            renderCalendarYear(yearEls[1], years[1], markedMap); 
            showIndex(activeIndex);
        }

        function annotateCoverageAndBadges(start, deliveries) {
            if (!start) return new Map(); 
            const lastDay = new Date(years[1], 11, 31); 
            const schedules = computeMarkedDates(start, lastDay);
            // We'll build a simple map: for each scheduled date, report whether it's covered
            // (delivery received) and which delivery covers it. Also compute remaining doses
            const map = new Map();
            const dl = (deliveries || []).slice().sort((a, b) => a.delivery_number - b.delivery_number);
            let scheduleIndex = 0;
            for (const dv of dl) {
                const qty = parseInt(dv.quantity || 0, 10) || 0;
                // compute how many doses already administered for this delivery
                const administeredCount = (dv.dose1 ? 1 : 0) + (dv.dose2 ? 1 : 0);
                const remaining = Math.max(0, qty - administeredCount);
                for (let k = 0; k < qty && scheduleIndex < schedules.length; k++, scheduleIndex++) {
                    const key = formatISO(schedules[scheduleIndex]);
                    map.set(key, { covered: !!dv.received, delivery_id: dv.id || 'local', delivery_number: dv.delivery_number });
                }
                // update any inline badges for delivery remaining
                const badge = document.querySelector('[data-delivery-id="' + (dv.id || 'local') + '"]');
                if (badge) badge.textContent = 'Rimanenti: ' + remaining;
            }
            return map;
        }

        function showIndex(i) { activeIndex = i; displayYearLabel.textContent = years[i]; containerEls.forEach((c, idx) => { if (idx === i) c.classList.remove('d-none'); else c.classList.add('d-none'); }); prevBtn.disabled = (i === 0); nextBtn.disabled = (i === years.length - 1); }

        function updateButtonStates() {
            const hasPlan = !!currentPlan;
            const resetPlanBtn = document.getElementById('resetPlanBtn');
            
            // Show only Save when no plan, only Delete when plan exists
            const cancelFormBtn = document.getElementById('cancelFormBtn');
            // Disable therapy start input when a saved plan exists
            try {
                if (therapyStartEl) therapyStartEl.disabled = hasPlan;
            } catch (e) { }
            if (hasPlan) {
                // plan saved: show only delete
                savePlanBtn.classList.add('d-none');
                resetPlanBtn.classList.remove('d-none');
                if (cancelFormBtn) cancelFormBtn.classList.add('d-none');
                // ensure reset button enabled
                if (resetPlanBtn) resetPlanBtn.disabled = false;
            } else {
                // no plan: show only save
                savePlanBtn.classList.remove('d-none');
                resetPlanBtn.classList.add('d-none');
                if (cancelFormBtn) cancelFormBtn.classList.add('d-none');
                if (savePlanBtn) savePlanBtn.disabled = false;
            }

            // Always keep style classes consistent
            if (hasPlan) {
                savePlanBtn.classList.add('disabled');
                resetPlanBtn.classList.remove('disabled');
            } else {
                savePlanBtn.classList.remove('disabled');
                resetPlanBtn.classList.add('disabled');
            }

            // Update add-delivery button state (show only when plan exists)
            try {
                if (addDeliveryBtn) {
                    if (!hasPlan || !currentPlan.deliveries) {
                        addDeliveryBtn.classList.add('d-none');
                        addDeliveryBtn.disabled = true;
                    } else {
                        addDeliveryBtn.classList.remove('d-none');
                        const hasPending = currentPlan.deliveries.some(d => !d.received);
                        addDeliveryBtn.disabled = !hasPending;
                    }
                }
            } catch (e) { console && console.error && console.error('updateButtonStates addDelivery error', e); }
            // Update preview text for add-delivery
            try { updateAddDeliveryPreview(); } catch (e) { /* ignore */ }
        }

        prevBtn.addEventListener('click', function () { if (activeIndex > 0) { showIndex(activeIndex - 1); } });
        nextBtn.addEventListener('click', function () { if (activeIndex < years.length - 1) { showIndex(activeIndex + 1); } });

        savePlanBtn.addEventListener('click', function () {
            // Simple: always create a new plan (server will check if one exists)
            const payload = { 
                start_date: therapyStartEl.value, 
                total_drugs: parseInt(currentTotalDrugs, 10) || 0
            };
            postForm('/sanita/api/plan', payload)
                .then(function(js) {
                    if (js.error) { 
                        if (js.error === 'plan_exists') {
                            window.showToast('Esiste già un piano. Eliminarlo prima di crearne uno nuovo.', 'warning');
                        } else {
                            window.showToast('Errore salvataggio piano', 'danger'); 
                        }
                        return; 
                    }
                    currentPlan = js.plan;
                    displayedDeliveries = currentPlan.deliveries || [];
                    renderDeliveries(displayedDeliveries);
                    updateButtonStates();
                    refresh();
                    window.showToast('Piano salvato', 'success');
                }).catch(() => { window.showToast('Errore salvataggio', 'danger'); });
        });

        // Plan extension UI and handler removed.

        // When therapy start changes, recompute local planned deliveries using currentTotalDrugs
        therapyStartEl.addEventListener('input', function () { 
            const start = parseDateInput(therapyStartEl.value); 
            localPlannedDeliveries = computePlannedDeliveries(currentTotalDrugs, start); 
            // If no plan saved, keep localPlannedDeliveries unmarked (no covered dates)
            renderDeliveries(localPlannedDeliveries); 
            refresh(); 
        });

        const resetPlanBtn = document.getElementById('resetPlanBtn');
        resetPlanBtn.addEventListener('click', function () {
            var msg = 'Confermi la cancellazione del piano terapeutico? Questa operazione è irreversibile.';
            var confirmFn = (window.showGlobalConfirm && typeof window.showGlobalConfirm === 'function') ? window.showGlobalConfirm : function(m){ return Promise.resolve(confirm(m)); };
            confirmFn(msg).then(function(confirmed){
                if (!confirmed) return;
                postForm('/sanita/api/plan', null, { method: 'DELETE' }).then(function(js) {
                    if (js.error) { window.showToast('Errore cancellazione piano', 'danger'); return; }
                    currentPlan = null; 
                    displayedDeliveries = []; 
                    currentTotalDrugs = defaultTotalDrugs;
                    therapyStartEl.value = formatISO(new Date()); 
                    localPlannedDeliveries = computePlannedDeliveries(currentTotalDrugs, parseDateInput(therapyStartEl.value));
                    // Keep local planned deliveries unmarked when no plan exists
                    renderDeliveries(localPlannedDeliveries);
                    // No per-delivery inline UI anymore
                    updateButtonStates();
                    refresh(); 
                    window.showToast('Piano cancellato', 'success');
                }).catch(() => { window.showToast('Errore cancellazione', 'danger'); });
            }).catch(function(){});
        });

        const cancelFormBtn = document.getElementById('cancelFormBtn');
        cancelFormBtn.addEventListener('click', function () { 
            therapyStartEl.value = formatISO(new Date()); 
            currentTotalDrugs = defaultTotalDrugs;
            localPlannedDeliveries = computePlannedDeliveries(currentTotalDrugs, parseDateInput(therapyStartEl.value)); 
            // Keep local planned deliveries unmarked when no plan exists
            renderDeliveries(localPlannedDeliveries); 
            currentPlan = null; 
            refresh(); 
        });

    function loadPlan() { 
        postForm('/sanita/api/plan', null, { method: 'GET', expect: 'json' }).then(js => { 
            if (js && js.plan) { 
                currentPlan = js.plan; 
                therapyStartEl.value = currentPlan.start_date || therapyStartEl.value; 
                // update internal total drugs from plan
                currentTotalDrugs = currentPlan.total_drugs || currentTotalDrugs;
                displayedDeliveries = currentPlan.deliveries || [];
                renderDeliveries(displayedDeliveries); 
            } else {
                currentPlan = null;
                displayedDeliveries = localPlannedDeliveries;
                // Keep local planned deliveries unmarked when no plan exists
                renderDeliveries(localPlannedDeliveries);
            }
                updateButtonStates();
                refresh(); 
        }).catch(() => { 
            window.showToast('Errore caricamento piano', 'danger'); 
        }); 
    }

        // Wire the add-delivery button: it acts as a one-shot action trigger similar to the previous checkbox
        function computeNextDeliveryDates() {
            if (!currentPlan) return null;
            const start = parseDateInput(therapyStartEl.value);
            const lastDay = new Date(years[1], 11, 31);
            const schedules = computeMarkedDates(start, lastDay);
            // count already covered slots
            const received = (currentPlan.deliveries || [])
                .map(d => ({ qty: parseInt(d.quantity || 0, 10) || 0, received: !!d.received }))
                .filter(x => x.received);
            let coveredCount = 0;
            for (const r of received) {
                coveredCount += r.qty;
            }
            // find next unreceived delivery
            const next = (currentPlan.deliveries || []).find(d => !d.received);
            if (!next) return null;
            const qty = parseInt(next.quantity || 0, 10) || 0;
            const res = [];
            for (let i = 0; i < qty && (coveredCount + i) < schedules.length; i++) {
                res.push(schedules[coveredCount + i]);
            }
            return { delivery_number: next.delivery_number, dates: res };
        }

    // Rely on global `formatDisplayDate` and `formatPrettyDate` from utils-format.js

        if (addDeliveryBtn) {
            addDeliveryBtn.addEventListener('click', function () {
                if (!currentPlan) return;
                const info = computeNextDeliveryDates();
                if (!info) { window.showToast('Nessuna consegna pendente da marcare', 'warning'); return; }
                const dn = info.delivery_number;
                const dates = info.dates || [];
                const pretty = dates.length ? dates.map(d => formatPrettyDate(d)).join(', ') : '(nessuna data prevista)';
                const msg = `Consegna #${dn} — ${pretty}`;
                var confirmMsg = msg + "\n\nConfermi di marcare questa consegna come ricevuta?";
                var confirmFn = (window.showGlobalConfirm && typeof window.showGlobalConfirm === 'function') ? window.showGlobalConfirm : function(m){ return Promise.resolve(confirm(m)); };
                confirmFn(confirmMsg).then(function(confirmed){
                    if (!confirmed) return;
                    try { if (addDeliverySpinner) addDeliverySpinner.classList.remove('d-none'); } catch(e){}
                    try { if (addDeliveryText) { addDeliveryText.textContent = 'Invio...'; addDeliveryText.classList.remove('d-none'); } } catch(e){}
                    addDeliveryBtn.disabled = true;
                    postForm('/sanita/api/delivery/next/mark')
                        .then(function(js) {
                        if (js.error) { window.showToast('Errore marcatura consegna', 'danger'); return; }
                        currentPlan = js.plan;
                        displayedDeliveries = currentPlan.deliveries || [];
                        renderDeliveries(displayedDeliveries);
                        updateButtonStates();
                        refresh();
                        window.showToast('Prossima consegna marcata come ricevuta', 'success');
                    }).catch(() => { window.showToast('Errore marcatura', 'danger'); })
                    .finally(() => {
                        try { if (addDeliverySpinner) addDeliverySpinner.classList.add('d-none'); } catch(e){}
                        try { if (addDeliveryText) { addDeliveryText.classList.add('d-none'); addDeliveryText.textContent = ''; } } catch(e){}
                        addDeliveryBtn.disabled = false;
                        try { updateButtonStates(); } catch(e) { /* ignore */ }
                    });
                });
            });
        }

        // Click handler for day cells: allow marking a specific scheduled date as administered
        function onCalendarDayClick(ev) {
            const target = ev.target.closest('.day');
            if (!target || target.classList.contains('empty')) return;
            const key = target.getAttribute('data-date');
            if (!key) return;
            // Only act on scheduled dates (marked)
            if (!target.classList.contains('marked')) {
                // not a scheduled date
                return;
            }
            // Only allow clicking the earliest pending scheduled dose: client-side guard.
            if (!target.classList.contains('clickable')) {
                const req = document.querySelector('.day.clickable');
                if (req && req.getAttribute) {
                    const rd = req.getAttribute('data-date');
                    try { window.showToast('Devi prima marcare la somministrazione del ' + formatDisplayDate(new Date(rd)), 'warning'); } catch(e) { window.showToast('Devi prima marcare la somministrazione precedente.','warning'); }
                } else {
                    window.showToast('Questa data non è cliccabile in questo momento.', 'warning');
                }
                return;
            }
            // If already administered, do not allow re-marking
            if (target.classList.contains('administered')) {
                window.showToast('Questa data è già marcata come somministrazione.', 'info');
                return;
            }
            // Only allow marking when the date is covered (delivery received)
            if (!target.classList.contains('covered')) {
                window.showToast('La data selezionata non è coperta da una fornitura ricevuta; non è possibile marcare la somministrazione.', 'warning');
                return;
            }
            // Confirm with the user
            const pretty = formatPrettyDate(new Date(key));
            var confirmMsg = 'Vuoi marcare la somministrazione per il ' + pretty + ' ?';
            var confirmFn = (window.showGlobalConfirm && typeof window.showGlobalConfirm === 'function') ? window.showGlobalConfirm : function(m){ return Promise.resolve(confirm(m)); };
            confirmFn(confirmMsg).then(function(confirmed){
                if (!confirmed) return;
                // Call backend to mark the delivery that covers this date
                postForm('/sanita/api/delivery/mark_date', { date: key })
                    .then(function(js) {
                    if (js.error) {
                            const msg = js.message || js.error;
                            if (js.error === 'already_received') {
                                window.showToast(msg || 'Questa somministrazione è già stata marcata.', 'info');
                            } else if (js.error === 'date_not_scheduled') {
                                window.showToast(msg || 'La data selezionata non corrisponde a una somministrazione programmata.', 'warning');
                            } else if (js.error === 'not_covered') {
                                window.showToast(msg || 'La consegna non è ancora stata ricevuta. Aggiungi la consegna prima di marcare la somministrazione.', 'warning');
                            } else if (js.error === 'order_violation') {
                                // If server suggests a required_date, show it nicely
                                if (js.required_date) {
                                    const rd = js.required_date;
                                    const prettyReq = formatDisplayDate(new Date(rd));
                                    window.showToast((msg || 'Devi prima marcare la prima dose della consegna.') + ' Data suggerita: ' + prettyReq, 'warning');
                                } else {
                                    window.showToast(msg || 'Devi prima marcare la prima dose della consegna.', 'warning');
                                }
                            } else {
                                window.showToast(msg || 'Errore marcatura data', 'danger');
                            }
                        return;
                    }
                    // Update local state and UI
                    currentPlan = js.plan;
                    displayedDeliveries = currentPlan.deliveries || [];
                    renderDeliveries(displayedDeliveries);
                    updateButtonStates();
                    refresh();
                    window.showToast('Somministrazione registrata', 'success');
        }).catch(() => { window.showToast('Errore marcatura', 'danger'); });
        });
    }

        // Attach delegated listener to both year containers
        const calendarYearEls = [document.getElementById('calendarYear1'), document.getElementById('calendarYear2')];
        calendarYearEls.forEach(yr => { if (yr) yr.addEventListener('click', onCalendarDayClick); });

        loadPlan();
        refresh();
        // Ensure add-delivery preview is initialized after load
        try { updateAddDeliveryPreview(); } catch (e) { /* ignore */ }
    });
</script>

{% endblock %}